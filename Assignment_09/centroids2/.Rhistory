## Step #22 ##
# access rankings for Penny & Stewie for episodes IV and VI
rankings[c(4,6),c(2,4)]
## Step #23 ##
# swap Lenny's rankings for Episodes II and V
# rank = Lenny's rankings for Episode II
rank = rankings[3,2]
## Step #23 ##
# swap Lenny's rankings for Episodes II and V
# rank = Lenny's rankings for Episode II
rank = rankings[2,3]
rankings[2,3] <- rankings[5,3]
View(rankings)
View(rankings)
rankings[5,3] <- rank
View(rankings)
View(rankings)
## Step #24 ##
# access Penny's rating of Episode III
allRankings["III", "Penny"]
## Step #24 ##
# access Penny's rating of Episode III
rankings["III", "Penny"]
View(rankings)
View(rankings)
df["III", "Penny"]
## Step #25 ##
rank2 = rankings["II", "Lenny"]
rankings["II", "Lenny"] <- rankings["V", "Lenny"]
rankings["V", "Lenny"] <- rank2
View(rankings)
View(rankings)
## Step #26 ##
# swapping AGAIN Lenny's rankings for Episdoes II and V
rank3 <- df$Lenny[2]
df$Lenny[2] <- df$Lenny[5]
df$Lenny[5] <- rank3
View(rankings)
View(rankings)
View(df)
View(df)
t <- c(80, 20, 40, 60, 100)
y <- 5000 * (1.005^t)
for (i in 5) {
print(hi)
}
for (i in 5) {
print("hi")
}
for (1 in 5) {
print("hi")
}
for (1 in 5) {
print("hi")
}
for (1 in 5) {
print("hi")
}
for (1 in five) {
print("hi")
}
five = 1:5
for (1 in five) {
print("hi")
}
for (1 in 1:5) {
print("hi")
}
for (i in 1:5) {
print("hi")
}
for (i in 1:5) {
print(i)
}
# for loop printing numbers 1 to 5
for (i in 1:5) {
print(i)
}
for (i in 1:10){
print("hi")
}
piggyBank <- 10 # dollars
allowance <- 5 # dollars per week
expenses <- 2 * 1.34 # dollars per week
weeks <- 8
for (i in 1:8){
piggyBank <- piggyBank + allowance - expenses
print( piggyBank )
}
shrinkingRate <- 0.05 # 5% rate
currentPopulation <- 2000 # individuals
years <- 7
for (i in 1:7){
currentPopulation <- currentPopulation*shrinkingRate
print( currentPopulation )
}
shrinkingRate <- 0.05 # 5% rate
currentPopulation <- 2000 # individuals
years <- 7
for (i in 1:7){
currentPopulation <- currentPopulation - currentPopulation*shrinkingRate
print( currentPopulation )
}
currentPopulation <- 2500 # population abundance
K <- 10000 # environmental carrying capacity for the population
r <- 0.8 # intrinsic growth rate of the population
for (i in 1:12){
currentPopulation <- currentPopulation + (r * currentPopulation * (K - currentPopulation)/K)
print( currentPopulation )
}
timeStep <- 12 # predicting population at t = 12
shrinkingRate <- 0.05 # 5% rate
currentPopulation <- 2000 # individuals
years <- 7
for (i in 1:years){
currentPopulation <- currentPopulation - currentPopulation*shrinkingRate
print( currentPopulation )
}
for (i in 1:years){
currentPopulation <- currentPopulation - currentPopulation*shrinkingRate
print( currentPopulation )
}
population <- 2500 # population abundance
K <- 10000 # environmental carrying capacity for the population
r <- 0.8 # intrinsic growth rate of the population
timeStep <- 12 # predicting population at t = 12
for (i in 1:timeStep){
population <- population + (r * population * (K - population)/K)
print( population )
}
K <- 10000 # environmental carrying capacity for the population
# Step 1
# A for loop that prints the word "hi" 10 times
hiTimes <- 10
# Aubrey Kroger
# EBIO 5420
# Lab04
# PART I #
# Step 1
# A for loop that prints the word "hi" 10 times
hiTimes <- 10
for (i in 1:hiTimes){
print("hi")
}
# Step 2
# For loop calcuating the total amount of money Tim has
piggyBank <- 10 # dollars
allowance <- 5 # dollars per week
expenses <- 2 * 1.34 # dollars per week
weeks <- 8
for (i in 1:weeks){
piggyBank <- piggyBank + allowance - expenses
print( piggyBank )
}
# Step 3
# For loop calculating expected population size
shrinkingRate <- 0.05 # 5% rate
currentPopulation <- 2000 # individuals
years <- 7
for (i in 1:years){
currentPopulation <- currentPopulation - currentPopulation*shrinkingRate
print( currentPopulation )
}
# Step 4
# For loop calculating population abundance using discrete-time logistic growth equation
population <- 2500 # population abundance
K <- 10000 # environmental carrying capacity for the population
r <- 0.8 # intrinsic growth rate of the population
timeStep <- 12 # predicting population at t = 12
for (i in 1:timeStep){
population <- population + (r * population * (K - population)/K)
print( population )
}
# Part II #
# Step 5a
# Making vector of 18 zeros
vector <- rep(0, 18)
# Step 5a
# Making vector of 18 zeros
zeros <- 18 # number of zeros in vector
vector <- rep(0, zeros)
print( vector )
for ( i in seq(1,18)) {
vector[i] <- 3 * i
}
for ( i in seq(1,18)) {
vector[i] <- 3 * i
}
print( vector )
# Step 5a
# Making vector of 18 zeros
zeros <- 18 # number of zeros in vector
vector <- rep(0, zeros)
print( vector )
# Step 5b
for ( i in seq(1,18)) {
vector[i] <- 3 * i
}
print( vector )
vectorTwo <- rep(0, zeros)
vectorTwo[1] <- 1
vectorTwo <- rep(0, zeros)
vectorTwo[1] <- 1
print( vectorTwo )
# Step 5d
for (i in seq(2, 18)) {
vectorTwo[i] <- 1 + (2 * vectorTwo[i-1])
}
print( vectorTwo )
length <- 20 #length of fibVector
fibVector <- rep(0, length)
fibVector[1] <- 0 # First number of Fibonacci sequence is zero
fibVector[2] <- 1 # Second number of Fibonacci sequence is one
for (i in 3:length) {
fibVector[i] <- fibVector[i - 1] + fibVector[i - 2]
}
# Should print first 20 Fibonacci numbers starting at 0
print( fibVector )
# Step 7
# defining variables
timeStep <- 12 # length of time vector and abundance vector
abundance <- rep(0, timeStep)
time <- rep(0, timeStep)
K <- 10000 # environmental carrying capacity for the population
r <- 0.8 # intrinsic growth rate of the population
# define starting values in both vectors
abundance[1] <- 2500 # population abundance at time t=1
time[1] <- 1 # time starts at t = 1
# For loop calculating population abundance using discrete-time logistic growth equation
for (i in 2:timeStep){
abundance[i] <- abundance[i - 1] + (r * abundance[i - 1] * (K - abundance[i - 1])/K)
time[i] <- time[i - 1] + 1 # increase time
}
print(abundance)
print(time)
# Step 7
# defining variables
timeStep <- 12 # length of time vector and abundance vector
abundance <- rep(0, timeStep)
time <- rep(0, timeStep)
K <- 10000 # environmental carrying capacity for the population
r <- 0.8 # intrinsic growth rate of the population
# define starting values in both vectors
abundance[1] <- 2500 # population abundance at time t=1
time[1] <- 1 # time starts at t = 1
# For loop calculating population abundance using discrete-time logistic growth equation
for (i in 2:timeStep){
abundance[i] <- abundance[i - 1] + (r * abundance[i - 1] * (K - abundance[i - 1])/K)
time[i] <- time[i - 1] + 1 # increase time
}
# plot population abundance over time
plot(time, abundance)
install.packages("tidyverse")
camData <- read.csv("~/Desktop/Classes/EBIO_5420/CompBioLabsAndHW/Lab09/Cusack_et_al_random_versus_trail_camera_trap_data_Ruaha_2013_14.csv", stringsAsFactors = F)
require("lubridate")
datesTimes2 <- parse_date_time(x = camData$DateTime,
orders = c("dmy HM", "dmY HM");
tz = "Africa/Kampala")
datesTimes2 <- parse_date_time(x = camData$DateTime,
orders = c("dmy HM", "dmY HM")
tz = "Africa/Kampala")
datesTimes2 <- parse_date_time(x = camData$DateTime,
orders = c("dmy HM", "dmY HM"),
tz = "Africa/Kampala")
require("dplyr")
require("dplyr")
speciesCountsByStation <- summarise(group_by(camData, Species, Station, Season), TotalCount = n(),
.groups = "drop")
require("tidyr")
scbsWide <- pivot_wider(speciesCountsByStation,
values_from = TotalCount,
names_from = Placement,
values_fill = 0)
scbsWide <- pivot_wider(speciesCountsByStation,
values_from = Freq,
names_from = Placement,
values_fill = 0)
speciesCountsByStation <- summarise(group_by(camData, Species, Station, Season), Freq = n(),
.groups = "drop")
require("tidyr")
scbsWide <- pivot_wider(speciesCountsByStation,
values_from = Freq,
names_from = Placement,
values_fill = 0)
speciesCountsByStation <- summarise(group_by(camData, Species, Station, Season))
speciesCountsByStation
speciesCountsByStation <- summarise(group_by(camData, Species, Station, Season),
TotalCount = n(),
.groups = "drop")
speciesCountsByStation
speciesCountsBySeason <- summarise(group_by(camData, Species, Station, Season),
TotalCount = n(),
.groups = "drop")
speciesCountsBySeason
which(speciesCountsBySeason$TotalCount == 0)
is.na(speciesCountsBySeason$TotalCount)
which(is.na(speciesCountsBySeason$TotalCount))
View(camData)
speciesCountsBySeason <- summarise(group_by(camData, Species, Station, Season),
TotalCount = n(),
)
speciesCountsBySeason
which(speciesCountsBySeason$TotalCount == 0)
which(is.na(speciesCountsBySeason$TotalCount))
install_github("aharmer/pathtrackr", build_vignettes = TRUE)
install Rtools
remotes::install_github("swarm-lab/trackR")
library(githubinstall)
install.packages("githubinstall")
githubinstall("trackR")
githubinstall::trackR
install.packages("devtools")
githubinstall::githubinstall("trackR")
githubinstall::githubinstall("trackR")
trackR()
# Independent Project
trackR()
githubinstall::githubinstall("trackR")
githubinstall::githubinstall("trackR")
install.packages("devtools")
install.packages("Cmake")
install.packages("ROpenCVLite")
githubinstall::githubinstall("trackR")
githubinstall::githubinstall("trackR")
devtools::install_github("swarm-lab/Rvision")
devtools::install_github("swarm-lab/Rvision")
installOpenCV()
install.packages("opencv")
devtools::install_github("swarm-lab/Rvision")
ROpenCVLite::installOpenCV(batch = TRUE)'
# Independent Project
library(trackR)
trackR()
# Independent Project
library(trackR)
trackR()
setwd("~/Desktop/Classes/EBIO_5420/CompBioLabsAndHW/Assignment_08/centroids2")
# Bind the rows of all of these csv files, select only Centroid_1 and 2 (x,y) and Time columns
df <- list.files(path="centroids_time", full.names = TRUE) %>%
lapply(read_csv) %>%
bind_rows %>%
select( Centroid_1, Centroid_2, Time ) %>%
arrange( Time ) %>%
filter( Centroid_1 > 200 ) # This is filtering out the centroid dots that were plotted on the axis points and time legend
library(dplyr)
library(readr)
require("lubridate")
require("dplyr")
# Bind the rows of all of these csv files, select only Centroid_1 and 2 (x,y) and Time columns
df <- list.files(path="centroids_time", full.names = TRUE) %>%
lapply(read_csv) %>%
bind_rows %>%
select( Centroid_1, Centroid_2, Time ) %>%
arrange( Time ) %>%
filter( Centroid_1 > 200 ) # This is filtering out the centroid dots that were plotted on the axis points and time legend
# These are other axis points that are not deleted by the filter function above (x axis ticks)
x <- c(257, 345, 432, 520, 608)
y <- c(602, 602, 602, 602, 602)
for( i in 1:length(x) ) {
index_x <- which( df[1] == x[i] )
index_y <- which( df[2] == y[i] )
to_delete <- intersect(index_x, index_y)
if( length(to_delete) > 0) {
df <- df[-to_delete, ]
}
}
View(df)
# Bind the rows of all of these csv files, select only Centroid_1 and 2 (x,y) and Time columns
df <- list.files(path="centroids_time", full.names = TRUE) %>%
lapply(read_csv) %>%
bind_rows %>%
select( Centroid_1, Centroid_2, Time ) %>%
arrange( Time ) %>%
filter( Centroid_1 > 200 ) # This is filtering out the centroid dots that were plotted on the axis points and time legend
x <- c(1, 1, 1, 1, 1, 1, 81, 83, 86.7, 89.7142857142857, 92.7692307692308, 95.6666666666667, 97, 97, 101.6875, 101.7, 106,
108.089285714286, 112.692307692308, 112, 112, 116.673076923077, 117, 122, 122.648648648649, 128.75, 169, 257, 345, 432, 520, 608)
y <- c(81, 169, 257, 344, 432, 520, 602, 4.5, 17.1, 3.5, 16.4615384615385, 3.5, 16, 21, 3.625, 17.1, 3.5,
17.6607142857143, 3.38461538461538, 16, 21, 17.7307692307692, 3.5, 3.04545454545455, 16.5945945945946,
3.375, 602, 602, 602, 602, 602, 602)
for( i in 1:length(x) ) {
index_x <- which( df[1] == x[i] )
index_y <- which( df[2] == y[i] )
to_delete <- intersect(index_x, index_y)
if( length(to_delete) > 0) {
df <- df[-to_delete, ]
}
}
# I want to label in df which one is a sheep dog
df <- cbind(df, Sheep = 0)
for( i in 1:length(SheepDX)) {
indexx <- which( df[1] == SheepDX[i])
indexy <- which( df[2] == SheepDY[i])
sheep_lab <- intersect(indexx, indexy)
if( length( sheep_lab ) == 1 ) {
df[sheep_lab, 4] <- 1
} else {
add_sheep <- data.frame( SheepDX[i], SheepDY[i], i, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
}
}
SheepDX <- c(245.961538461538, 247.981132075472, 249.037735849057, 249.055555555556, 251, 251.962264150943, 252.981481481481,
255.038461538462, 259, 261.018181818182, 261.962264150943, 263.962962962963, 267.038461538462, 269.882352941176,
270.018518518519, 272, 270.901960784314, 267.038461538462, 265.05556, 263.035714285714, 263.037735849057,
263.037735849057, 263.055555555556, 265.072727272727, 267.944444444444, 273.089285714286, 281.055555555556, 289.960784313725,
299.037735849057, 307, 313.055555555556, 319, 323, 327.055555555556, 333.961538461538, 341.944444444444, 352, 363.037735849057,
374.018181818182, 387.037735849057, 400.018181818182, 413, 422.981818181818, 432.018181818182, 438.981818181818, 443.944444444444,
447.038461538462, 449.980769230769, 453.888888888889, 459.037735849057, 464, 469.018181818182, 473.071428571429, 477, 481.072727272727,
483.945454545455, 487.055555555556, 490, 491.039215686275, 491.038461538462, 488, 483.981818181818, 483.981818181818,
475.944444444444, 471.962264150943, 467, 461.88, 455.962264150943, 451.037735849057, 441, 435, 435, 438, 437.037037037037, 437.962264150943,
435.962264150943, 433.961538461538, 432.037037037037, 431.076923076923, 429.038461538462, 427, 424, 421, 415.962264150943,
417.057692307692, 416.01724137931, 415, 416, 413, 410, 402, 395, 390, 385, 383, 380, 379, 375, 385.037735849057, 384, 383, 382.018181818182,
380.963636363636, 381.961538461538, 385.038461538462, 385.038461538462, 383, 379.961538461538, 377.078431372549, 373.018181818182, 370,
369.037037037037, 369.055555555556, 368, 367, 364.964285714286, 363.037735849057, 360, 357, 355, 361.037735849057, 363, 362, 357.981481481481, 353.072727272727,
351.019230769231, 354, 359.037735849057, 361.962264150943, 362, 359.037735849057, 355.962264150943, 353.944444444444, 352, 351.037735849057, 351,
347.84, 344.019230769231, 339.944444444444, 339.055555555556, 337.981132075472, 333.88, 331, 330, 327, 325, 324, 321, 318, 316, 313, 310, 307, 305, 305, 305, 304.017857142857,
302, 299, 296, 292, 289, 287, 285, 285, 285, 284, 284, 284, 283.944444444444, 281.055555555556, 279, 277, 274, 269, 264, 259, 258, 257, 256, 255, 254, 250, 248, 246,
244, 244, 243.5, 243.5, 243.081632653061, 242, 240.018518518519, 237, 233, 228, 228, 228, 227.903846153846, 224, 221.862745098039)
SheepDY <- c(310.961538461538, 310.962264150943, 311, 309.981481481481, 308.962264150943, 308, 306.055555555556,
304.038461538462, 302.964285714286, 302.981818181818, 304, 304.055555555556, 304.961538461538, 307,
308.888888888889, 308, 308.058823529412, 304.961538461538, 302.018519, 300, 299,
299, 302, 303, 300.018518518519, 294, 288.981481481481, 284, 280, 278, 274.981481481481, 272.962264150943, 272.035714285714,
273, 272.038461538462, 270, 267, 264, 261.981818181818, 258.094339622641, 255.018181818182, 251, 245.981818181818, 237.981818181818,
229.981818181818, 220.018518518519, 206.961538461538, 194.076923076923, 179.981481481481, 167, 155, 144.018181818182, 132.946428571429,
124, 115, 106.072727272727, 97, 90.0727272727273, 83, 74.9615384615385, 68.0377358490566, 62.9818181818182, 62.9818181818182,
64.0185185185185, 68, 72.1176470588235, 76.04, 77.9811320754717, 81, 78, 83, 85, 90.0377358490566, 94.9444444444444, 100, 103,
106.961538461538, 110.018518518519, 114.980769230769, 118.942307692308, 122.960784313725, 123.962264150943, 122, 123, 128.961538461538,
132.948275862069, 138, 147, 158, 157, 155, 154, 154, 155.5, 160, 163, 166, 170, 176, 181.964285714286, 186.094339622642, 186.127272727273,
186.109090909091, 190.961538461538, 202.038461538462, 212.961538461538, 218.150943396226, 212.961538461538, 202.941176470588, 192.018181818182,
189, 188.925925925926, 194.981481481481, 203, 210, 212.875, 211, 210, 208, 213, 223, 235.037735849057, 240.035714285714, 238.055555555556, 232,
228.865384615385, 234.037735849057, 244, 254, 257, 253.981132075472, 252, 249.018518518519, 249.035714285714, 249, 248, 244.1,
236.076923076923, 229.981481481481, 233.018518518519, 238.962264150943, 243.04, 250, 253, 255, 257, 261, 265, 263, 262, 264, 267, 270, 271.5, 271.5, 271.5, 276.928571428571,
280, 284, 280, 279, 283, 285, 289, 290, 291, 292, 292, 292, 294.981481481481, 297.018518518519, 299, 301, 304, 305, 304, 303, 302, 301, 300, 299, 298, 296, 295.5, 295,
295, 293, 291, 295, 294.897959183673, 292.962264150943, 290.055555555556, 288, 287, 285.9, 290, 290, 290.076923076923, 287, 284.058823529412)
for( i in 1:length(SheepDX)) {
indexx <- which( df[1] == SheepDX[i])
indexy <- which( df[2] == SheepDY[i])
sheep_lab <- intersect(indexx, indexy)
if( length( sheep_lab ) == 1 ) {
df[sheep_lab, 4] <- 1
} else {
add_sheep <- data.frame( SheepDX[i], SheepDY[i], i, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
}
}
View(df)
which(df[1] == SheepDX[1])
which(df[2] == SheepDY[2])
intersect(1, 1)
intersect(2,2)
intersect(1, 2)
intersect(3, 3)
View(df)
indexx
intersect(indexx, indexy)
num <- intersect(1, 2)
length(num)
# 63 didnt work
add_sheep <- data.frame(SheepDX[63], SheepDY[63], 63, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
# 155 didnt work
add_sheep <- data.frame(SheepDX[155], SheepDY[155], 155, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
# 156 didnt work
add_sheep <- data.frame(SheepDX[156], SheepDY[156], 156, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
# 168 didnt work
add_sheep <- data.frame(SheepDX[168], SheepDY[168], 168, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
# 169 didnt work
add_sheep <- data.frame(SheepDX[169], SheepDY[169], 169, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
# 186 didnt work
add_sheep <- data.frame(SheepDX[186], SheepDY[186], 186, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
# 197
add_sheep <- data.frame(SheepDX[197], SheepDY[197], 197, 1)
names( add_sheep ) <- c( "Centroid_1", "Centroid_2", "Time", "Sheep")
df <- rbind(df, add_sheep)
# sheepdog = sheepdog centroid at each time
sheepdog <- df %>%
filter( Sheep == 1 ) %>%
select( Centroid_1, Centroid_2, Time ) %>%
arrange( Time )
# double value for some reason in row 189??
sheepdog <- sheepdog[-189, ]
# sheeps = all of the sheep centroids at each time
sheeps <- df %>%
filter( Sheep == 0) %>%
select( Centroid_1, Centroid_2, Time ) %>%
arrange( Time )
# average_sheeps = centroid of flock at each time (centroid is determined as the average of the sheep locations)
average_sheeps <- sheeps %>%
group_by( Time ) %>%
summarise( mean_x = mean(Centroid_1), mean_y = mean(Centroid_2))
# sheep_distance = distance from sheepdog to centroid of flock over time
# create sheep_distance data frame
sheep_distance <- data.frame(matrix(NA, nrow = 200, ncol = 2))
names(sheep_distance) <- c("distance", "time")
for( i in 1:200 ) {
# for each time frame, calculate the distance of the sheepdog from the center of the flock
sheep_distance$distance[i] <- (average_sheeps$mean_x[i] - sheepdog$Centroid_1[i])^2 + (average_sheeps$mean_y[i] - sheepdog$Centroid_2[i])^2
# distance equation used is (x1 - x2)^2 + (y1 - y2)^2
sheep_distance$time[i] <- i
}
